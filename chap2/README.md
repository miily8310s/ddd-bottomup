# 2 章 システム固有の値を表現する「値オブジェクト」

## 2-1 値オブジェクトとは

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap2/SampleCodes/2-1.ts)

- 値オブジェクト = システム固有の値を表現するために定義されたオブジェクト
  - システムに最適な値は必ずしもプリミティブ（単純）な値であるとは限らない
  - サンプルコードの FullName クラスは、値にもオブジェクトにも当てはまる値オブジェクトの一例

## 2-2 値の性質と値オブジェクトの実装

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap2/SampleCodes/2-2.ts)

- 値がもつ性質を学ぶことは値オブジェクトを知る上で重要な事柄
- 代表的な値の性質は次の 3 つ
  - 不変である
  - 交換が可能である
  - 等価性によって比較される
- 値オブジェクトは値の一種なので、上記値の性質も適用される

### 交換が可能である

- 値は不変であるが、ソフトウェアを作る上で値を変更せずに目的を達成することは困難
- 交換（代入）なら値の変更ができる
- サンプルコードはすべて代入によって値オブジェクトの値を変更している

### 等価性によって比較される

- 値の比較は左辺と右辺でインスタンスとして別個のものだが、値を構成する属性によって、
  比較される（=等価として判定されることもある ）
- 値オブジェクトは値と同じように値オブジェクト同士で比較できる方が自然
- 値オブジェクトのクラスで比較メソッド（今回のサンプルコードだと equals メソッド）があることで、値オブジェクトに新たな属性が追加されてもこのクラス内のメソッドの修正だけで済む
  - 比較処理だけでなく値を操作する処理は値オブジェクトのクラスが提供してまとめる

## 2-3 値オブジェクトにする基準

- FullName クラスを構成する firstName や lastName 属性は値オブジェクトではなく、プリミティブな文字型列
- システムに登場する概念のうち、どこまでを値オブジェクトにするかは難しい
  - 単純にドメインモデルとして定義される概念は値オブジェクトに定義される
- ドメインモデルとして挙げられなかった概念を値オブジェクトにすべきかの判断基準は２つ
  - そこにルールが存在しているか
  - それ単体で取り扱いたいか
- サンプルコードでは
  - 氏名には「姓と名で構成される」　のルールが存在するので、値オブジェクトになる
  - 姓や名は「使用可能な文字種が制限される」のルールを作ることができる
    - こちらは値オブジェクトにしなくてもしても実現できる
    - 値オブジェクトにした場合はサンプルコードの Name クラスの書き方ができる

## 2-4 ふるまいを持った値オブジェクト

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap2/SampleCodes/2-4.ts)

- 値オブジェクトで重要なこと=「独自のふるまいを定義できること」
- 今回はお金を表現するお金オブジェクトで考えてみる
  - お金には量と通貨単位（例：ドル、円）の２つの属性がある
  - サンプルコードは Money クラス
    - 独自のふるまいとしてお金を加算する Add メソッドを定義
    - 通貨単位が異なる場合はエラーを投げる

### 定義されないからこそわかること

- オブジェクトに定義されるふるまいは、そのオブジェクトができることを示す
  - = 逆に定義されていないふるまいは、オブジェクトではできない

## 2-5 値オブジェクトを採用するモチベーション

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap2/SampleCodes/2-5.ts)

- 値オブジェクトを採用するには、数多くの心理的ハードルを乗り越える必要がある
- 値オブジェクトを使うモチベーションは次の４つ
  - 表現力が増す
  - 不正な値を存在させない
  - 誤った代入を防ぐ
  - ロジックの散財を防ぐ

### 表現力が増す

- 工業製品の製品番号をプリミティブな文字列で表現する
  - サンプルコードの変数 modalNumber
  - 製品番号=modalNumber は「-」「数字」「アルファベット」の３種類から構成
  - ただし変数 modalNumber はプリミティブな文字列のままだとパット見何を表しているのかわからない（無口な文字列）。
    - なので値オブジェクトに変更する（サンプルコードの ModalNumber クラス）
- 値オブジェクトはその定義によって自分がどういったものであるかを主張する自己文書化をすすめる

### 不正な値を存在させない

- システムに存在する値にはルールが存在する
- 例えばユーザー名にはこんなルールがある
  - 「ユーザー名の文字数は N 文字以上 M 文字以下」
  - 「利用できる文字はアルファベットと数字のみ」
- 不正なルールは if 条件などの確認で回避することはできるが、開発者は何度も同じルールを書く羽目になる
- 値オブジェクトを利用して不正チェックすることで、こうした不正な値を防ぐことができる＆開発者としても何度も書く必要がなくなる
  - サンプルコードの UserName クラス

### 誤った代入を防ぐ

- 開発者は値の代入を間違えることもある
- コードの正当性はコード見ただけでは判別できない
  - 正しさを判定するにはシステムがどういう仕様になっているか深く知る必要がある
  - コードの正しさの証明には関係者の記憶やドキュメントに頼るよりも、自己文書化をすすめるべき
- 値オブジェクトを使って代入する変数の型が間違っていたらエラーが検出されるようにする
  - サンプルコードの UserId, UserName, User クラス
  - 今回は User クラスの id プロパティに UserId 型、name プロパティには UserName 型を定義する

### ロジックの散財を防ぐ

- コードの重複を防ぐことは重要
  - 重複を許すと変更に対する難易度が上がる
  - 開発者に重複するコードを探索されることを強いられ、慎重さと労力が要求される
- 値オブジェクトでこうしたルールを事前にまとめておくことで、そのルールが変更されてもコードの変更箇所が１箇所で済む
- ルールをまとめる作業こそ重要
- サンプルコードは UserId, UserName, User クラス、createUser/updateUser メソッド

## 2-6 まとめ

- 値オブジェクトのコンセプト=「システム固有の値を作ろう」
- プリミティブな値だけでソフトウェアは構築可能だが、プリミティブ型は汎用的かつ表現力が乏しくなってしまう
- 値オブジェクトを定義することでドメインのルールも値オブジェクト内に記述され、コードがドキュメントとして機能する
  - システムの仕様は一般的にドキュメントにまとめられるが、キャビネットなどからそうしたドキュメントを取り出す手間を減らす努力は継続すべき
- 値オブジェクトはドメイン駆動設計で基本のパターン
  - ドメインの概念をオブジェクトとして定義する際は、まず値オブジェクトに当てはまることを検討すべき
