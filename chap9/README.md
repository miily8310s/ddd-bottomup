# ９章　複雑な生成処理を行う「ファクトリ」

- ファクトリ：作る知識に特化したオブジェクト
- オブジェクトの生成はときに複雑な手順を必要とする
  - このとき、モデルを表現するオブジェクトに無理やり実装するべきではない
  - オブジェクトの生成自体を独立したオブジェクトに実装すべき
  - 道具を作ることと使うことは全く別の知識であるのと同様
- ファクトリはオブジェクトを生成する責務をもったオブジェクト

## 9-1 ファクトリの目的

- 世の中の道具は内部構造に詳しくなくても恩恵を受けられる一方、複雑な道具はその生成過程も複雑
- 複雑なオブジェクトはその生成過程が複雑になることがある
- 求められること：複雑なオブジェクトの生成処理をオブジェクトとして定義する
  - この生成を責務とするオブジェクト = 「ファクトリ」
  - ※ここでのファクトリ = 道具を作る工場

## 9-2 採番処理をファクトリに実装した例の確認

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap9/SampleCodes/)

- ファクトリが活躍するわかりやすい例として採番処理がある
- システムによって採番処理をコントロールしたいときがある
  - 今回は User クラスの採番処理をシーケンス（※連続しているもの）を利用するように書き換えてみる
- 可能であればテスト用に気軽に（FactoryUser クラスの）インスタンスを生成したいときは適当な ID を振り、さもなければデータベース接続して採番を行えるようにしたい
  - このように採番処理を切り替えたい場合はファクトリが役立つ
  - ファクトリ用のインターフェイスを用意する

### 自動採番機能の活用

- データベースの自動採番機能を活用する手もある
- ただし自動採番機能を利用するといくつかの懸念事項が発生する
- 利用する場合は開発上のルールを良く周知すること

### リポジトリに採番用メソッドを用意する

- ファクトリではなく、リポジトリに採番を行うメソッドを用意する方法もある
- 開発チームでの合意が取れているならこのパターンの採用もあり
- ただし筆者としては、リポジトリはデータの永続化と再構築を行うオブジェクトなので、採番処理までを手を伸ばすと責務を広げている気がするので非推奨

## 9-3 ファクトリとして機能するメソッド

- クラス自体がファクトリとなる以外に、メソッドがファクトリとして機能することもある
  - オブジェクトの内部データを利用してインスタンスを生成する必要があるときに利用される
- インスタンスを渡してあげることでインスタンスの内部情報を引き渡すことができる

## 9-4 複雑な生成処理をカプセル化しよう

- 単純に生成方法が複雑なインスタンスを構築する処理をまとめるためにファクトリを利用するのも良い習慣
- 本来であれば初期化はコンストラクタの役目
  - ただしコンストラクタは単純である必要がある
  - 複雑な初期化はファクトリを使って定義する
- 「コンストラクタ内で他のオブジェクトを生成するかどうか」はファクトリを作る際の動機づけに良い指標となる
- ただ漫然とインスタンス化をするのではなく、ファクトリを導入すべきか検討する習慣を身につけるべき

## 9-5 まとめ

- ファクトリ：オブジェクトのライフサクルの始まりで、その役割を果たす
- 複雑な処理を伴うオブジェクトの生成にファクトリを使用することで
  - コードの論点が明確に
  - 全く同じ生成処理がそこかしこに記述されることを防ぐことができる
- ファクトリによって生成処理をカプセル化することは、ロジックの意図を明確にしながら、柔軟性を確保する大切なこと
