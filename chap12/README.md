# 第１２章　ドメインのルールを守る「集約」

- 集約 = データを変更するための単位として扱われるオブジェクトの集まり
- 集約にはルートとなるオブジェクトが存在し、すべての操作はルート越しに行われる
  - そのため、集合内部への操作に制限がかかり、集約内の不変条件は維持される
- 集約は変更の単位であるため、トランザクションやロックとも密接に関係する

## 12-1 集約とは

- オブジェクト指向プログラミングでは複数のオブジェクトがまとめられ、ひとつの意味を持ったオブジェクトが構築される
  - こうしたオブジェクトには維持されるべき**不変条件**が存在する
  - **不変条件**：ある処理の間、その真理値が真のまま変化しない述語
- オブジェクトのデータを変更する操作を無制限に受け入れてしますと、不変条件の維持が難しくなる
- 集約は不変条件を維持する単位として切り出され、オブジェクトの操作に秩序をもたらす
- 集約には境界とルートが存在する
  - 境界：集約に何が含まれるのかを定義するための境界
  - ルート：集約に含まれる特定のオブジェクト
- 外部からの集約に対する操作はすべて集約ルートを経由して行われる
  　- 集約の境界内に存在するオブジェクトを外部にさらけ出さないことで、集約内の不変条件を維持できるようにしている
- 第１１章で登場していた`User`や`Circle`クラスは集約にあたる

### 集約の基本的構造

- 集約は関連するオブジェクト同士を線で囲う境界として定義される
- 集約を操作するためのオブジェクトは集約ルートと呼ばれるオブジェクト限定

- 例えば、下記コードでユーザー名の変更は集約ルートである User オブジェクトに依頼をする形で行わければいけない

  - `changeName`といったメソッドを用意することで引き渡された値の確認が行えるため、不正なデータの存在を防ぐことができる

  ```ts
  const userName = new UserName("NewName");

  // NG
  userName.name = userName;

  // OK
  user.changeName(userName);
  ```

- 次はサークル集約について確認
- サークル集約に含まれる「サークル名の操作」「サークルのメンバーを追加する」処理は集約ルート越しに行う必要がある

  - ※ユーザ集約の情報を変更する処理はサークル集約からは行わない

- 第１１章で登場したサークルにメンバーを追加するコードは次の形だった
- ただしこれは集約のルールに違反している

```ts
circle.getMembers().push(member);
```

- この場合は Circle オブジェクトへのメソッド追加が望ましい

  - サークルのメンバー追加もこのメソッドを通すしか方法がない
  - 「サークルに所属するユーザの最大数はサークルのオーナーとなるユーザを含めて３０名まで」という不変条件も常に維持できる
  - 次の形でメソッドを追加する

  ```ts
  export class Circle {
    private id: CircleId;
    private name: CircleName;
    private owner: User;
    // メンバーは非公開に
    private members: User[];
    // ...（略）
    public join(member: User) {
      if (!member) {
        throw new Error(`ArgumentNullException member`);
      }
      if (this.members.length >= 29) {
        throw new Error(`CircleFullException ${this.id}`);
      }
      this.members.push(member);
    }
  }
  ```

- オブジェクト指向プログラミングでは、外部から内部のオブジェクトに対して直接操作するのではなく、それを保持するオブジェクトに以来する形を取る
- そうすることで直感的かつ不変条件を維持することができる「デメテルの法則」

### オブジェクトの操作に関する基本的な原則

- 「デメテルの法則」はオブジェクト同士のメソッド呼び出しに秩序をもたらすガイドライン
- デメテルの法則によると、メソッドを呼び出すオブジェクトは次の４つに限定される
  - オブジェクト自身
  - インスタンス変数
  - 引数として渡されたオブジェクト
  - 直接インスタンス化したオブジェクト
- デメテルの法則が解決したい問題を紐解いて見る
- メンバーを追加する際の上限チェックで使用するコードが以下の形である
  ```ts
  if (circle.members.length >= 29) {
    throw new Error(`CircleFullException ${this.id}`);
  }
  ```
- このコードは Circle オブジェクトのプロパティである Members を直接操作し、length プロパティを呼び出している
  - 上限チェック用のロジックが点在することを助長してしまう
  - デメテルの法則の「メソッドを呼び出しているオブジェクト」のいずれにもあてはまらない
- デメテルの法則に従い次のようにコードを書き換える
  ```ts
  // （略）
  public isFull():boolean {
    return members.length >= 29;
  };
  public join(member: User) {
    if (!member) {
      throw new Error(`ArgumentNullException member`);
    }
    // 上限チェックのコードはすべてisFullメソッドに置き換わる
    if (isFull) {
      throw new Error(`CircleFullException ${this.id}`);
    }
    this.members.push(member);
  }
  ```
- もし上限数が変更されていても isFull メソッドの修正だけで解決する
- デメテルの法則はソフトウェアのメンテナンス性を向上させ、コードをより柔軟なものへ導く

### 内部データを隠蔽するために

- オブジェクトの内部データはむやみに公開すべきものではない
- しかし完全に非公開にするとリポジトリがインスタンスを永続化しようとしたときに困ったことがおこる
  - User クラスの id や name が非公開になり、コンパイルエラーがおこる
- この問題に対するアプローチは２つある
  - ルールによる防衛（=ゲッターを使わない）→ 制限力が低いのが難点
  - 通知オブジェクトを使用する

## 12-2 集約をどう区切るか

- 集約をどのように区切るか、はとても難しいテーマ
- その方針でもっともメジャーなものは「変更の単位」
- 「変更の単位」が集約の境界を引く理由となることを理解するには、あえて違反してみるとわかりやすい
- 集約のルールに違反して、サークルの集約越しにユーザ集約へ変更を加えてみる
  - `Circle`クラスにサークルに所属するメンバーのユーザ名を変更する処理を追加
  - リポジトリのコードにサークル集約を永続化する処理を追加する
- 結果サークルリポジトリのロジックの多くがユーザの更新処理に汚染されてしまう
  - この更新処理用のコードとほとんど同じものがユーザのリポジトリにも存在し、コードの重複が起こる
- 集約に対する変更はあくまで集約自身に実施させ、永続化の依頼も集約ごとに行われる必要がある
  - こういった理由からリピ地鶏は変更の単位である集約ごとに用意する

### ID によるコンポジション

- `Circle` オブジェクトに `User` のインスタンスを保持している影響で、プロパティ経由でそのメソッドを呼び出すことが可能なことこそが問題であるという見方もある
- `Circle`オブジェクトに`User` のインスタンスをもたせない選択肢もある
- サークル集約でユーザ集約を直接保持するのではなく、識別子をインスタンスの代わりとして保持するように修正してみる

  ```ts
  export class Circle {
      private id: CircleId;
      private name: CircleName;
      private owner: User;
      //識別子を保持するように修正
      //private members: User[];
      private members: UserId[]
  ```

- こうすることで User オブジェクトを再構築するための処理能力も節約でき、インスタンスを保持するメモリも節約できる
