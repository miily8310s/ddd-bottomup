# ６章 ユースケースを実現する「アプリケーションサービス」

- アプリケーションサービスはドメインオブジェクトを強調させてユースケースを実現する
- ドメインオブジェクトはドメインモデルをコードによって表現したオブジェクト
  - ex）値オブジェクト、エンティティ
- ソフトウェアとして利用者の問題を解決するためには、これらのドメインオブジェクトをまとめ上げて問題を解決するように導く必要がある
- アプリケーションサービスはドメインオブジェクトが行うタスクの進行を管理し、問題の解決に導くもの

## 6-1 アプリケーションサービスとは

- ４章：不自然さを解決する「ドメインサービス」でも触れた２つ目のサービス
- アプリケーションサービス＝ユースケースを実現するオブジェクト
- 例えばユーザ登録の必要なシステムにおいて、ユーザ機能を実現するには次のユースケースが必要になる
  - 「ユーザを登録する」ユースケース
  - 「ユーザを変更する」ユースケース
- ユーザ機能のアプリケーションサービスはこれらのユースケースに従って、次のふるまいが定義される
  - 「ユーザを登録する」ふるまい
  - 「ユーザを変更する」ふるまい
- これらのふるまいは実際にドメインオブジェクトを組み合わせて実行するスクリプトのようなふるまい
- 本章ではこうしたユーザ機能に必要なユースケースを作成する過程を確認することで、アプリケーションサービスがどういったものか確認していく

## 6-2 ユースケースを組み立てる

- アプリケーションサービスのサンプルとして本章では SNS のユーザ機能を取り上げる
- システムとして成り立たせるために開発しなくてはならないものを洗い出すため、まずはユーザ機能がどういったものかを確認する
- ユーザ機能を実現するには次の４つのユースケースが必要
  - ユーザを登録する
  - ユーザ情報を取得する
  - ユーザ情報を更新する
  - ユーザを退会する
- これらの処理はいわゆる CRUD（CREATE, READ, UPDATE, DELETE）処理

### ドメインオブジェクトから準備する

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap6/SampleCodes/)
の UseCaseUser.ts/UseCaseUserService.ts/IUseCaseUserRepository.ts

- まずはアプリケーションサービスが取り扱うドメインオブジェクトを準備
- 今回のユーザーの概念はライフサイクルがあるモデルなので、エンティティとして実装される
- User にはシステム固有の値オブジェクトとして UserId とユーザ名を定義
- ユーザの重複がないことを確認するために、ドメインサービスも用意
- さらにユーザの永続化や再構築を行うためにリポジトリも必要
  - この段階ではリポジトリはインターフェイスの定義のみで OK
  - 実装クラスはまだ用意する必要はなし

### ユーザ登録処理を作成する

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap6/SampleCodes/)
の UseCaseUserApplicationService.ts

- 最初にユーザ登録処理のアプリケーションサービスを実装
- Register メソッドでは最初に User オブジェクトを生成し、UserService に重複チェックをお願いしている
- そして重複しないことを確認した場合、IUserRepository にインスタンスの永続化を依頼
- こうしてユーザの登録を完了する
- TODO：クラス名を修正
- なお今回アプリケーションサービスとして定義した xxxx クラスは[第５章](https://github.com/miily8310s/ddd-bottomup/blob/master/chap5/SampleCodes/5-2.ts)で出てきた RepositoryProgram クラスと同じコード

### ユーザ情報取得処理を作成する

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap6/SampleCodes/)
の UseCaseUser.ts/UseCaseUserService.ts/IUseCaseUserRepository.ts

- ユーザ情報の取得処理をアプリケーションサービスに追加する
- ユーザ情報取得処理はユーザ登録処理と異なり、結果を返却する必要がある
- このとき結果として返却されるオブジェクトが、ドメインオブジェクトをそのまま戻り値として返却するか否かの選択は重要な分岐点
- ドメインオブジェクトをそのまま返却する選択肢を選んでみる
  - アプリケーションサービスの実装コードは比較的シンプルに
  - しかし同時にわずかな危険性をはらむ
  - この危険性はアプリケーションサービスを利用するクライアントで起こりうる
- アプリケーションサービス以外のオブジェクトがドメインオブジェクトの直接のクライアントとなって自由に操作できてしまう問題が発生している
- ドメインオブジェクトの振る舞いを呼び出す役目はアプリケーションサービスが取るべき
- ドメインオブジェクトを外部に向けて公開するのを防ぐ選択肢として、データ転送用オブジェクト（DTO、Data Transfer Object）がある
- 今回なら、クライアントで返却するオブジェクトをドメインオブジェクトの代わりに DTO を返すようにする
- DTO はそのクラス自他を定義する手間とデータの移し替えを行うため、ドメインオブジェクトを直接公開した場合に比べるとパフォーマンス上劣る部分がある
  - ただしよほど大量の移し替えをしなければ、手間は微々たるもの
- ドメインオブジェクトを公開するか否かは大きな分岐点
  - どちらを採用するかはプロジェクトのポリシーによる
  - その選択はソフトウェアの未来を左右する可能性の秘めた決定事項であることを認識した上で決定を下すべき

### ユーザ情報更新処理を作成する

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap6/SampleCodes/)
の UseCaseUserUpdateCommand.ts

- 更新処理では項目ごとに別々のユースケースとするか、それとも単一のユースケースで複数項目を同時更新できるようにするかは悩ましい問題
- 今回は複数項目を同時に更新できるユースケースをサンプルにする
- User オブジェクトの情報に今後もユーザ名以外にもぱパラメータが増えたらどのように変化するのか？
- 情報変更にあたってユーザ名だけ、メールアドレスだけを変更したいときもある
- ユーザ情報が追加されるたびにアプリケーションサービスのメソッドのシグネチャが変更されることになる
- これを避ける方法としてコマンドオブジェクトを用いる戦術がある
- コマンドオブジェクトを作ることは間接的にアプリケーションサービスの処理を制御することと同義

## 6-3 ドメインのルールの流出
