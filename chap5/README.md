# ５章 データにまつわる処理を分離する「リポジトリ」

- リポジトリは永続化や再構築を担う
- オブジェクトの永続化（保存）や再構築（復元）といった操作は重要だが、データストアを操作するコードはプラグラムの意図をぼやけさせる
- 意図を明確にするにはデータストアにまつわる処理を切り離すことが必要
- リポジトリはそういった操作を抽象的に扱えるようにし、処理の意図を明確にさせる
  - データストアにまつわる処理がリポジトリに寄るため、データストアの差し替えも実現できる
  - テスト実行も容易になる
- リポジトリはソフトウェアの柔軟性に寄与する重要なパターン

- ※ データストア：DB などデータを溜めておく場所のこと

## 5-1 リポジトリとは

- ソフトウェア開発の文脈におけるリポジトリ=データの保管庫
- オブジェクトを繰り返し利用するには、何らかのデータストアにオブジェクトのデータを永続化（保存）し、再構築（復元）する必要がある
- リポジトリはこの「データを永続化（保存）し、再構築（復元）する」処理を抽象的に扱うためのオブジェクト
- オブジェクトのインスタンスを保存したいときは
  - X 直接データストアに書き込みを行う処理を実行する
  - ○ リポジトリにインスタンスの永続化を依頼する

## 5-2 リポジトリの責務

[サンプルコード](https://github.com/miily8310s/ddd-bottomup/blob/master/chap5/SampleCodes/5-2.ts)

- リポジトリの責務はドメインオブジェクトの永続化と再構築を行うこと
- 永続化=インスタンスを保存し、復元できるようにすること
- 永続化を行う技術基盤の例）
  - リレーショナルデータベース
  - データを保存するファイル
  - NoSQL データベース
- 永続化を実施するために記述される特定のデータストアに基づく具体的な手順は大抵ややこしい
- 第４章 4-4 で出てきたユーザー作成処理を改めてここで確認
  - コードの前半部分でユーザー生成と重複確認を行っている点は確認しやすい
  - 後半部分では
    - リレーショナルデータベースの操作を行っていることは読み取れる
    - しかし User オブジェクトのインスタンスを保存していることまではすぐ読み取れない状態
  - コードの大半をデータストアの具体的な操作に追われてしまっており、趣旨が読み取りづらくなってしまっている
- ユーザ作成処理をリポジトリを利用した実装に書き換えてみる
  - データストアに対する命令はリポジトリに移動
  - ドメインサービスにはこのリポジトリをセットし、ユーザの重複確認を行わせる
    - その結果、SQL の発行など実際のデータストアの処理がリポジトリに移動し、ユーザ作成手順の純粋なロジックだけが残り、確認しやすいコードになった

## 5-3 リポジトリのインターフェイス

- 5-2 で使用するサンプルコードを改めて確認
- 重複確認用の exists メソッドはリポジトリにも置くことは出来なくはない
- しかしリポジトリの責務はあくまでもオブジェクトの永続化
  - ユーザの重複確認はドメインサービスのルールに近い
  - またリポジトリに実装してしまうと、リポジトリの実装次第で動作が変わる可能性がある

## 5-4 SQL を利用したリポジトリを作成する

- interface で定義したリポジトリ用の型を使って、リポジトリ用 class を作成

## 5-5 テストによる確認

- ソフトウェアを開発するにあたり、テストは欠かせないもの
- プログラムが開発者の意図通りの動作をしているかどうかは常に確認する必要がある
  - その代表的な方法がテスト
- ドメインの変化を受けてソフトウェアが偏するためにはテストを用意することが重要

### テストに必要な作業を確認する

- テストの実施にはリレーショナルデータベースが必要
- ただしロジックが増えるに従って、データベースのテーブルを適宜追加する必要がある
- 確認したい項目にしたがって最適なテスト用のデータをいちいち投入しなければいけない
- これらは恒久的に行いたい作業か？

### 祈り信者のテスト理論

- 効率化に熱心な開発者に撮って、「たいてい」うまく動作するコードに対して多大な労力をかけてテストを行うことは、コストと対価が見合わないように感じられてしまう
- 結果、動く「だろう」で記述したコードが正しく動くように祈ることが増えてしまう
- もちろん祈ることが最善策ではない
- プログラムの挙動が祈ることで変わることはありえない

### 祈りを捨てよう

- 現在の問題はテストをするためにデータベースをインストールしたり、テーブルを準備しなくてはいけなかったりと、準備作業が煩雑なこと
- これを解消するためにはデータベースを利用しなければよい
- データベースに依存しないテスト用のリポジトリを作ればよい

**※5-6/5-7 については C#特有の説明が大半なので読み流す程度に留める**

## 5-8 リポジトリに定義されるふるまい

- リポジトリにはオブジェクトの永続化と再構築に関するふるまいが定義される

### 永続化に関するふるまい

- オブジェクトを永続化するふるまいは既にサンプルとして登場している save メソッド
- 永続化のふるまいは永続化を行うオブジェクトを引数に取る
  - したがって、識別子と更新項目を引き渡して更新させるようなメソッドは用意しない
  - 下の悪い例コードも参照
- オブジェクトを作成する処理もリポジトリに定義しない
- またオブジェクトの破棄に関する操作も永続化のふるまいの一つ

  - データストアからデータ削除する場合など

- 悪い例コード
  ```ts
  interface IUserRepository {
    updateName(id: userID, name: userName) => void;
    updateEmail(id: userID, mail: email) => void;
    updateAddress(id: userID, address: address) => void;
  }
  ```

### 再構築に関するふるまい

- もっとも頻繁に利用される再構築のふるまいは識別子によって検索されるメソッド

## 5-9 まとめ

- ロジックが特定のインフラストラクチャ技術に依存することはソフトウェアを硬直化させることに繋がる
- コードの大半がデータストアに対する詳細な操作に汚染され、処理の目的がぼやけてしまう
- リポジトリを利用することでデータの永続化にまつわる処理を抽象化することができる
- リポジトリをうまく活用して処理の意図を明確にすることは、皇族の開発者の助けになる
